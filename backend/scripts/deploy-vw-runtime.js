/**
 * Auto-deploy VW runtime artifacts for local startup.
 * - Ensures a readable model file exists.
 * - Ensures runtime config points to an executable VW binary path.
 * - Falls back to local vw-shim for dev/test environments.
 */

import fs from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';
import { getRecoRuntimeConfig, updateRecoRuntimeConfig } from '../reco/configStore.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const BACKEND_DIR = path.join(__dirname, '..');
const AUTO_MODEL_DIR = path.join(BACKEND_DIR, 'data', 'vw');
const AUTO_MODEL_PATH = path.join(AUTO_MODEL_DIR, 'bootstrap.model');
const AUTO_BINARY_PATH = path.join(BACKEND_DIR, 'scripts', 'vw-shim.js');

const exists = async (targetPath) => {
  try {
    await fs.access(targetPath);
    return true;
  } catch {
    return false;
  }
};

const normalize = (value) => {
  const raw = String(value || '').trim();
  return raw ? path.resolve(raw) : '';
};

const ensureAutoModel = async () => {
  await fs.mkdir(AUTO_MODEL_DIR, { recursive: true });
  if (!(await exists(AUTO_MODEL_PATH))) {
    const modelSeed = [
      '# xinchat bootstrap vw model',
      '# generated by backend/scripts/deploy-vw-runtime.js',
      `# createdAt=${new Date().toISOString()}`,
      '',
    ].join('\n');
    await fs.writeFile(AUTO_MODEL_PATH, modelSeed, 'utf8');
  }
  return AUTO_MODEL_PATH;
};

const resolveTargetRuntime = async (currentConfig) => {
  const envBinaryRaw = String(process.env.VW_BINARY_PATH || '').trim();
  const envModelRaw = String(process.env.VW_MODEL_PATH || '').trim();
  const envBinary = envBinaryRaw ? normalize(envBinaryRaw) : '';
  const envModel = envModelRaw ? normalize(envModelRaw) : '';

  if (envBinary && envModel && (await exists(envBinary)) && (await exists(envModel))) {
    return { binaryPath: envBinary, modelPath: envModel, source: 'env' };
  }

  const currentBinary = normalize(currentConfig?.vwBinaryPath || '');
  const currentModel = normalize(currentConfig?.vwModelPath || '');
  if (currentBinary && currentModel && (await exists(currentBinary)) && (await exists(currentModel))) {
    return { binaryPath: currentBinary, modelPath: currentModel, source: 'runtime' };
  }

  const autoModelPath = await ensureAutoModel();
  const autoBinaryPath = normalize(AUTO_BINARY_PATH);
  return { binaryPath: autoBinaryPath, modelPath: autoModelPath, source: 'auto' };
};

const main = async () => {
  const current = await getRecoRuntimeConfig();
  const target = await resolveTargetRuntime(current);

  const needPatch =
    normalize(current?.vwBinaryPath || '') !== normalize(target.binaryPath) ||
    normalize(current?.vwModelPath || '') !== normalize(target.modelPath);

  if (needPatch) {
    await updateRecoRuntimeConfig(
      {
        vwBinaryPath: target.binaryPath,
        vwModelPath: target.modelPath,
      },
      { actor: 'npm_backend_autodeploy_vw' }
    );
  }

  const ready = (await exists(target.binaryPath)) && (await exists(target.modelPath));
  console.log(
    `[vw-deploy] source=${target.source} vw ready: ${ready ? 'YES' : 'NO'}`
  );
  console.log(`[vw-deploy] binary=${target.binaryPath}`);
  console.log(`[vw-deploy] model=${target.modelPath}`);
};

main().catch((error) => {
  console.error(`[vw-deploy] failed: ${String(error?.message || error)}`);
  process.exit(1);
});
